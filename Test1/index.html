<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <!-- Include the CesiumJS JavaScript and CSS files -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.92/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.92/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
</head>

<body>
    <div id="cesiumContainer"></div>
    <script>
        var myAjax = new XMLHttpRequest(); // Tạo đối tượng XMLHttpRequest
        myAjax.open("GET", "squaw_creek_container_info.xml", false); //Mở file 
        myAjax.setRequestHeader("Content-Type", "text/xml"); //Đặt header với content-type là text/xml
        myAjax.send(null); //Gửi yêu cầu
        var xmlDocument = myAjax.responseXML; //Lấy nội dung XML từ file và trả về biến xmlDocument
        var po = xmlDocument.getElementsByTagName("POINT"); // Lấy các thẻ có tên là POINT
        var li = xmlDocument.getElementsByTagName("LINE");

        //Set up Cesium
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyMWNlZGZiZC1hZDBkLTRlYzktOTdiMS0yZjFkN2IyZDA1MmMiLCJpZCI6ODk4NjgsImlhdCI6MTY0OTk4NjY0Nn0.YmDNYZ3GH7ahtkPAiCnRm5l5w2Quv_eMJO0IwPpYzPM';
        const viewer = new Cesium.Viewer('cesiumContainer', {
            terrainProvider: Cesium.createWorldTerrain()
        });
        const buildingTileset = viewer.scene.primitives.add(Cesium.createOsmBuildings());

        //Draw Point
        for (i = 0; i < po.length; i++) {
            drawAllPoint(po[i].attributes[0].value)
        }

        //Draw Line
        for (var i = 0; i < li.length; i++) {
            drawAllLine(li[i].attributes[1].value);
        }

        function pointInLine(point1, point2) {
            var poDegree1, poDegree2;
            for (var i = 0; i < po.length; i++) {
                if (po[i].attributes[1].value === point1) {
                    poDegree1 = po[i].attributes[0].value;
                }
                if (po[i].attributes[1].value === point2) {
                    poDegree2 = po[i].attributes[0].value;
                }
            }
            return {
                poDe1: poDegree1,
                poDe2: poDegree2,
            }
        }

        function sliceLine(linePath) {
            var po1, po2;
            for (var i = 0; i < linePath.length; i++) {
                if (linePath[i] === ',') {
                    po1 = linePath.slice(0, i);
                    po2 = linePath.slice(i + 2, linePath.length);
                    break;
                }
            }
            return {
                point1: po1,
                point2: po2,
            }
        }

        function sliceDegree(degree) {
            var longitude, latitude, height, checki;
            for (var i = 0; i < degree.length; i++) {
                if (degree[i] === ',') {
                    longitude = degree.slice(0, i);
                    checki = i;
                    break;
                }
            }
            for (var j = checki + 2; j < degree.length; j++) {
                if (degree[j] === ',') {
                    latitude = degree.slice(checki + 2, j);
                    height = degree.slice(j + 2, degree.length);
                    break;
                }
            }
            return {
                longitude: longitude,
                latitude: latitude,
                height: height,
            }
        }

        function drawAllPoint(degree) {
            var takeDegree = sliceDegree(degree);
            drawPoint(takeDegree.longitude, takeDegree.latitude, takeDegree.height)
        }

        function drawPoint(a, b, c) {
            const point = viewer.entities.add({
                name: 'Point',
                description: '<p>\
                    Point from degree: </p>\ ' +
                    'Longitude: ' + a +
                    '</br>\ Latitude: ' + b +
                    '</br>\ Latitude: ' + c,
                position: Cesium.Cartesian3.fromDegrees(a, b, c),
                point: {
                    pixelSize: 10,
                    color: Cesium.Color.RED,
                },
            });
            return point;
        }

        function drawAllLine(linePath) {
            var takePo = sliceLine(linePath);
            var tkPoDegree = pointInLine(takePo.point1, takePo.point2);
            var slDr1 = sliceDegree(tkPoDegree.poDe1);
            var slDr2 = sliceDegree(tkPoDegree.poDe2);
            drawLine(slDr1.longitude, slDr1.latitude, slDr1.height, slDr2.longitude, slDr2.latitude, slDr2.height);
        }

        function drawLine(a, b, c, d, e, f) {
            const line = viewer.entities.add({
                name: "Line",
                polyline: {
                    positions: Cesium.Cartesian3.fromDegreesArrayHeights([a, b, c, d, e, f]),
                    width: 2,
                    material: Cesium.Color.YELLOW,
                },
            });
            return line;
        }
        drawPolygon();
        function drawPolygon() {
            const redPolygon = viewer.entities.add({
                name: "Red polygon on surface",
                polygon: {
                    hierarchy: Cesium.Cartesian3.fromDegreesArrayHeights([
                        -93.62052154541016, 42.01856231689453, 279.42364501953125,
                        -93.62052917480469, 42.01852798461914, 279.4580993652344,
                        -93.62052917480469, 42.01852798461914, 279.4580993652344,
                        -93.6205062866211, 42.01852798461914, 278.27490234375,
                        -93.6205062866211, 42.01852798461914, 278.27490234375,
                        -93.62052154541016, 42.01856231689453, 279.42364501953125,
                    ]),
                    perPositionHeight: true,
                    material: Cesium.Color.GREEN,
                },
            });
        }

    </script>
    </div>
</body>

</html>